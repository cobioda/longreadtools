<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="A suite of utilities designed for handling isomatrices, which are generated by scisclor. These tools facilitate tasks such as converting isomatrices to AnnData format, merging multiple isomatrices, and more. Additionally, the suite includes features for downloading or generating isomatrix data, which can be particularly useful for testing and demonstrating new features.">

<title>longreadtools - Isomatrix Tools</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="longreadtools - Isomatrix Tools">
<meta property="og:description" content="A suite of utilities designed for handling isomatrices, which are generated by scisclor. These tools facilitate tasks such as converting isomatrices to AnnData format, merging multiple isomatrices, and more. Additionally, the suite includes features for downloading or generating isomatrix data, which can be particularly useful for testing and demonstrating new features.">
<meta property="og:site_name" content="longreadtools">
<meta name="twitter:title" content="longreadtools - Isomatrix Tools">
<meta name="twitter:description" content="A suite of utilities designed for handling isomatrices, which are generated by scisclor. These tools facilitate tasks such as converting isomatrices to AnnData format, merging multiple isomatrices, and more. Additionally, the suite includes features for downloading or generating isomatrix data, which can be particularly useful for testing and demonstrating new features.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">longreadtools</span>
    </a>
  </div>
        <div class="quarto-navbar-tools">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./isomatrix_tools.html">Isomatrix Tools</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LongReadTools</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./harmonisation_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Harmonization Tools</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./inference_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Inference Tools</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./isomatrix_tools.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Isomatrix Tools</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./visualization_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Visualization Tools</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#isomatrix_to_anndata" id="toc-isomatrix_to_anndata" class="nav-link active" data-scroll-target="#isomatrix_to_anndata">isomatrix_to_anndata</a></li>
  <li><a href="#download_test_data" id="toc-download_test_data" class="nav-link" data-scroll-target="#download_test_data">download_test_data</a></li>
  <li><a href="#simulate_isomatrix" id="toc-simulate_isomatrix" class="nav-link" data-scroll-target="#simulate_isomatrix">simulate_isomatrix</a></li>
  <li><a href="#simulate_and_save_isomatrices" id="toc-simulate_and_save_isomatrices" class="nav-link" data-scroll-target="#simulate_and_save_isomatrices">simulate_and_save_isomatrices</a></li>
  <li><a href="#convert_and_save_file" id="toc-convert_and_save_file" class="nav-link" data-scroll-target="#convert_and_save_file">convert_and_save_file</a></li>
  <li><a href="#multiple_isomatrix_conversion" id="toc-multiple_isomatrix_conversion" class="nav-link" data-scroll-target="#multiple_isomatrix_conversion">multiple_isomatrix_conversion</a></li>
  <li><a href="#feature_set_standardization" id="toc-feature_set_standardization" class="nav-link" data-scroll-target="#feature_set_standardization">feature_set_standardization</a></li>
  <li><a href="#check_anndata_for_saving" id="toc-check_anndata_for_saving" class="nav-link" data-scroll-target="#check_anndata_for_saving">check_anndata_for_saving</a></li>
  <li><a href="#make_unique_batch_keys" id="toc-make_unique_batch_keys" class="nav-link" data-scroll-target="#make_unique_batch_keys">make_unique_batch_keys</a></li>
  <li><a href="#concatenate_anndata" id="toc-concatenate_anndata" class="nav-link" data-scroll-target="#concatenate_anndata">concatenate_anndata</a></li>
  <li><a href="#make_unique_batch_keys-1" id="toc-make_unique_batch_keys-1" class="nav-link" data-scroll-target="#make_unique_batch_keys-1">make_unique_batch_keys</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/cobioda/longreadtools/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Isomatrix Tools</h1>
</div>

<div>
  <div class="description">
    A suite of utilities designed for handling isomatrices, which are generated by scisclor. These tools facilitate tasks such as converting isomatrices to AnnData format, merging multiple isomatrices, and more. Additionally, the suite includes features for downloading or generating isomatrix data, which can be particularly useful for testing and demonstrating new features.
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>The Isomatrix Tools module provides a comprehensive set of utilities for working with isomatrices, particularly those generated by the scisclor tool. One of the key functionalities of this module is the conversion of isomatrix text files, which are the output of scisclor, into AnnData objects that are compatible with the Scanpy library. This conversion process is crucial for enabling downstream analysis of single-cell long-read data within the Scanpy ecosystem, allowing users to leverage its powerful analytical capabilities. The module ensures that the conversion retains all necessary gene and transcript information, and it supports the creation of both dense and sparse matrix representations to cater to different computational needs.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L15" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="isomatrix_to_anndata" class="level3">
<h3 class="anchored" data-anchor-id="isomatrix_to_anndata">isomatrix_to_anndata</h3>
<blockquote class="blockquote">
<pre><code> isomatrix_to_anndata (file_path:str, sparse:bool=False)</code></pre>
</blockquote>
<p>This function converts an isomatrix txt file (SiCeLoRe output) into an AnnData object compatible with scanpy</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>file_path</td>
<td>str</td>
<td></td>
<td>The path to the isomatrix csv file to be read.</td>
</tr>
<tr class="even">
<td>sparse</td>
<td>bool</td>
<td>False</td>
<td>Flag to determine if the output should be a sparse matrix.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>AnnData</strong></td>
<td></td>
<td><strong>The converted isomatrix as a scanpy compatible anndata object</strong></td>
</tr>
</tbody>
</table>
<p>This section pertains to the retrieval of sample data which is essential for testing and validating the functionality of the Isomatrix Tools module. The sample data is an isomatrix text file, which is a typical output of the SiCeLoRe pipeline, and is used to ensure that the conversion to an AnnData object is performed correctly. The downloaded file is also used in the demonstration and testing of other functions within this module.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L65" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="download_test_data" class="level3">
<h3 class="anchored" data-anchor-id="download_test_data">download_test_data</h3>
<blockquote class="blockquote">
<pre><code> download_test_data ()</code></pre>
</blockquote>
<p>This function downloads a test data file from a specified URL, saves it locally, and extracts it.</p>
<p>The Isomatrix Tools module includes functionality to simulate an isomatrix, which is a matrix representation of transcript expression data. This simulated data can be used for testing and validation purposes within the Isomatrix Tools framework. The simulation is designed to mimic the structure and characteristics of real transcriptomic datasets, allowing users to generate data with specified parameters such as the number of genes, transcripts per gene, number of samples, sparsity of the matrix, and maximum expression levels. The simulate_isomatrix function in the code block below provides a practical example of how such data can be generated for use with Isomatrix Tools.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L98" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="simulate_isomatrix" class="level3">
<h3 class="anchored" data-anchor-id="simulate_isomatrix">simulate_isomatrix</h3>
<blockquote class="blockquote">
<pre><code> simulate_isomatrix (num_genes:int, num_transcripts_per_gene:int,
                     num_samples:int, sparsity:float=0.95,
                     max_expression:int=100, seed:int=0)</code></pre>
</blockquote>
<p>Simulate transcript expression data to match the structure of the first image provided by the user. Allows specifying the number of genes, transcripts per gene, and samples.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>num_genes</td>
<td>int</td>
<td></td>
<td>number of genes (groups of rows)</td>
</tr>
<tr class="even">
<td>num_transcripts_per_gene</td>
<td>int</td>
<td></td>
<td>number of transcripts per gene</td>
</tr>
<tr class="odd">
<td>num_samples</td>
<td>int</td>
<td></td>
<td>number of samples (columns)</td>
</tr>
<tr class="even">
<td>sparsity</td>
<td>float</td>
<td>0.95</td>
<td>fraction of zeros in the data (default 0.95)</td>
</tr>
<tr class="odd">
<td>max_expression</td>
<td>int</td>
<td>100</td>
<td>maximum expression level for any transcript in any sample</td>
</tr>
<tr class="even">
<td>seed</td>
<td>int</td>
<td>0</td>
<td>random seed for reproducibility</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>DataFrame</strong></td>
<td></td>
<td><strong>DataFrame with simulated transcript expression data for demonstration purposes.</strong></td>
</tr>
</tbody>
</table>
<p>The isomatrix_tools module provides functionality to simulate and generate multiple isomatrix datasets. These datasets are essential for testing and demonstrating the capabilities of downstream analysis tools. The simulation process involves creating synthetic gene expression data that closely resembles real-world isomatrix data structures. This includes the ability to specify the number of genes, transcripts per gene, samples, and control the sparsity and maximum expression levels of the generated data. The simulate_and_save_isomatrices function within this module is particularly useful for creating a series of isomatrix files, which can be saved to a specified directory for further use in pipeline testing or demonstration purposes. The function also offers options to return the file paths of the generated isomatrices and to output progress messages during the simulation process.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L142" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="simulate_and_save_isomatrices" class="level3">
<h3 class="anchored" data-anchor-id="simulate_and_save_isomatrices">simulate_and_save_isomatrices</h3>
<blockquote class="blockquote">
<pre><code> simulate_and_save_isomatrices (num_isomatrix:int, num_genes:int,
                                num_transcripts_per_gene:int,
                                num_samples:int, sparsity:float=0.95,
                                max_expression:int=100, seed:int=0,
                                output_dir:str='./',
                                return_paths:bool=False,
                                verbose:bool=False)</code></pre>
</blockquote>
<p>Simulate multiple isomatrix and save them as txt files in the specified directory. If return_paths is True, return a list of paths to the saved isomatrix files.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>num_isomatrix</td>
<td>int</td>
<td></td>
<td>number of isomatrix to generate</td>
</tr>
<tr class="even">
<td>num_genes</td>
<td>int</td>
<td></td>
<td>number of genes (groups of rows)</td>
</tr>
<tr class="odd">
<td>num_transcripts_per_gene</td>
<td>int</td>
<td></td>
<td>number of transcripts per gene</td>
</tr>
<tr class="even">
<td>num_samples</td>
<td>int</td>
<td></td>
<td>number of samples (columns)</td>
</tr>
<tr class="odd">
<td>sparsity</td>
<td>float</td>
<td>0.95</td>
<td>fraction of zeros in the data (default 0.95)</td>
</tr>
<tr class="even">
<td>max_expression</td>
<td>int</td>
<td>100</td>
<td>maximum expression level for any transcript in any sample</td>
</tr>
<tr class="odd">
<td>seed</td>
<td>int</td>
<td>0</td>
<td>random seed for reproducibility</td>
</tr>
<tr class="even">
<td>output_dir</td>
<td>str</td>
<td>./</td>
<td>directory to save the generated isomatrix txt files</td>
</tr>
<tr class="odd">
<td>return_paths</td>
<td>bool</td>
<td>False</td>
<td>return paths to the isomatrixs as a list of strings if True</td>
</tr>
<tr class="even">
<td>verbose</td>
<td>bool</td>
<td>False</td>
<td>print progress messages if True</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td></td>
<td><strong>list of paths for the simulated matrices (if return is set True)</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L181" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="convert_and_save_file" class="level3">
<h3 class="anchored" data-anchor-id="convert_and_save_file">convert_and_save_file</h3>
<blockquote class="blockquote">
<pre><code> convert_and_save_file (sample:str, verbose:bool, sparse:bool=False)</code></pre>
</blockquote>
<p>Convert an isomatrix txt file to an AnnData h5ad file and save it to disk. If the file already exists, it is overwritten. A delay and retry mechanism is implemented to handle file locking issues.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sample</td>
<td>str</td>
<td></td>
<td>path to the isomatrix txt file</td>
</tr>
<tr class="even">
<td>verbose</td>
<td>bool</td>
<td></td>
<td>print progress messages if True</td>
</tr>
<tr class="odd">
<td>sparse</td>
<td>bool</td>
<td>False</td>
<td>store the anndata object in sparse format if True</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td></td>
<td><strong>path to the converted h5ad file</strong></td>
</tr>
</tbody>
</table>
<p>#he Isomatrix tools module provides a suite of functions designed to facilitate the conversion of isomatrix files into AnnData objects, which are suitable for downstream analysis in single-cell genomics workflows. This module includes a function <a href="https://cobioda.github.io/longreadtools/isomatrix_tools.html#multiple_isomatrix_conversion"><code>multiple_isomatrix_conversion</code></a> that efficiently processes batches of isomatrix files, leveraging parallel processing to expedite the conversion. The converted AnnData objects can optionally be stored in a sparse format to optimize memory usage. Additionally, the module contains functions for handling file I/O operations, such as checking for the existence of files and implementing a retry mechanism to address file locking issues during the write process. The module also includes functionality to standardize feature sets across multiple datasets, ensuring consistency in subsequent analyses.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L214" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="multiple_isomatrix_conversion" class="level3">
<h3 class="anchored" data-anchor-id="multiple_isomatrix_conversion">multiple_isomatrix_conversion</h3>
<blockquote class="blockquote">
<pre><code> multiple_isomatrix_conversion (file_paths:list, verbose:bool=False,
                                return_paths:bool=False,
                                sparse:bool=False)</code></pre>
</blockquote>
<p>This function takes a list of file paths, converts each file from isomatrix to anndata format, and saves the converted file in the same location with the same name but with a .h5ad extension. If return_paths is True, it returns a list of paths to the converted files. If sparse is True, the anndata object will be stored in sparse format.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>file_paths</td>
<td>list</td>
<td></td>
<td>A list of file paths to be converted.</td>
</tr>
<tr class="even">
<td>verbose</td>
<td>bool</td>
<td>False</td>
<td>If True, print progress messages.</td>
</tr>
<tr class="odd">
<td>return_paths</td>
<td>bool</td>
<td>False</td>
<td>If True, return a list of paths to the converted files.</td>
</tr>
<tr class="even">
<td>sparse</td>
<td>bool</td>
<td>False</td>
<td>If True, the anndata object will be stored in sparse format.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td></td>
<td><strong>A list of paths to the converted files.</strong></td>
</tr>
</tbody>
</table>
<p>The Isomatrix tools module includes advanced functionality for standardizing transcript features across multiple isoform matrix datasets. This process is crucial for ensuring that subsequent analyses are consistent and comparable. The module provides the option to standardize features by either taking the union or the intersection of all transcripts present in the datasets. The ‘union’ method combines all unique transcripts from each dataset, thus preserving the full range of features. In contrast, the ‘intersection’ method retains only those transcripts that are common to all datasets, which can be beneficial for comparative studies where only shared features are of interest. This flexibility allows researchers to tailor the standardization process to their specific analytical needs and the nature of their datasets.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L241" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="feature_set_standardization" class="level3">
<h3 class="anchored" data-anchor-id="feature_set_standardization">feature_set_standardization</h3>
<blockquote class="blockquote">
<pre><code> feature_set_standardization (adatas:list,
                              standardization_method:str='union')</code></pre>
</blockquote>
<p>Standardize the feature sets of multiple AnnData objects.</p>
<p>This function takes a list of AnnData objects or paths to AnnData files and a standardization method as input. The standardization method can be either ‘union’ or ‘intersection’. If ‘union’ is chosen, the function will create a union of all features across all AnnData objects. If ‘intersection’ is chosen, the function will create an intersection of all features across all AnnData objects. The function returns a list of standardized AnnData objects.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>adatas</td>
<td>list</td>
<td></td>
<td>list of AnnData objects or paths to AnnData files</td>
</tr>
<tr class="even">
<td>standardization_method</td>
<td>str</td>
<td>union</td>
<td>str specifiying method to use union or intersection</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td></td>
<td><strong>list of anndata objects with the features standardised</strong></td>
</tr>
</tbody>
</table>
<p>The Isomatrix tools module includes a function to validate and prepare an AnnData object for serialization and storage. This function ensures that the AnnData object conforms to the requirements for writing to disk as an .h5ad file, which is the file format used by Scanpy’s <code>write_h5ad</code> method. The function checks for the presence of missing values in the <code>.var</code> and <code>.obs</code> DataFrames, converts non-string categorical data to strings, ensures that the observation and variable names are of string data type, and verifies that there are no duplicate names. Additionally, it checks for NaN values in the <code>.X</code> attribute, which holds the main data matrix, and provides warnings if any issues are detected that could interfere with the file writing process. This preprocessing step is crucial for maintaining data integrity and ensuring compatibility with downstream analysis tools that rely on the .h5ad file format.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatool.py#L320" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="check_anndata_for_saving" class="level3">
<h3 class="anchored" data-anchor-id="check_anndata_for_saving">check_anndata_for_saving</h3>
<blockquote class="blockquote">
<pre><code> check_anndata_for_saving (adata:anndata._core.anndata.AnnData,
                           verbose:bool=False)</code></pre>
</blockquote>
<p>Prepare an AnnData object for saving by ensuring proper data types and handling missing values.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>adata</td>
<td>AnnData</td>
<td></td>
<td>The AnnData object to check.</td>
</tr>
<tr class="even">
<td>verbose</td>
<td>bool</td>
<td>False</td>
<td>If True, print status messages. Defaults to False.</td>
</tr>
</tbody>
</table>
<p>This module provides functionality to concatenate multiple AnnData objects, which are essential data structures for storing large-scale single-cell genomics data. The concatenation process is designed to combine data from different batches or experiments, while ensuring that the resulting AnnData object maintains the integrity and structure necessary for downstream analysis. The Isomatrix tools facilitate this process by handling discrepancies in data types, filling missing values, and standardizing feature sets across all input datasets. This ensures that the concatenated dataset is ready for high-throughput computational analyses, such as clustering, visualization, and differential expression testing, which are common in single-cell genomics workflows.</p>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L369" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="make_unique_batch_keys" class="level3">
<h3 class="anchored" data-anchor-id="make_unique_batch_keys">make_unique_batch_keys</h3>
<blockquote class="blockquote">
<pre><code> make_unique_batch_keys (batch_keys)</code></pre>
</blockquote>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L382" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="concatenate_anndata" class="level3">
<h3 class="anchored" data-anchor-id="concatenate_anndata">concatenate_anndata</h3>
<blockquote class="blockquote">
<pre><code> concatenate_anndata (h5ad_inputs:list, standardization_method='union',
                      sparse=False, verbose=False)</code></pre>
</blockquote>
<p>This function concatenates multiple AnnData objects into a single AnnData object and adds batch keys to identify the origin of each sample.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>h5ad_inputs</td>
<td>list</td>
<td></td>
<td>A list of AnnData objects or paths to .h5ad files.</td>
</tr>
<tr class="even">
<td>standardization_method</td>
<td>str</td>
<td>union</td>
<td>The method to standardize the feature sets across all AnnData objects. It can be either ‘union’ or ‘intersection’. Default is ‘union’.</td>
</tr>
<tr class="odd">
<td>sparse</td>
<td>bool</td>
<td>False</td>
<td>Optional flag to convert the final matrix to sparse. Default is False.</td>
</tr>
<tr class="even">
<td>verbose</td>
<td>bool</td>
<td>False</td>
<td>Optional flag to print progress updates. Default is False.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>AnnData</strong></td>
<td></td>
<td><strong>The concatenated AnnData object.</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/cobioda/longreadtools/blob/main/longreadtools/isomatrix_tools.py#L369" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="make_unique_batch_keys-1" class="level3">
<h3 class="anchored" data-anchor-id="make_unique_batch_keys-1">make_unique_batch_keys</h3>
<blockquote class="blockquote">
<pre><code> make_unique_batch_keys (batch_keys)</code></pre>
</blockquote>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/cobioda/longreadtools/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>